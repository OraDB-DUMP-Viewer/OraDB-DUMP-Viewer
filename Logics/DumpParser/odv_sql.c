/*****************************************************************************
    OraDB DUMP Viewer

    odv_sql.c
    SQL INSERT statement output

    Generates INSERT INTO statements for various DBMS targets:
    - Oracle:     Standard Oracle SQL syntax
    - PostgreSQL: Follows PG quoting conventions
    - MySQL:      Backtick identifiers
    - SQL Server: Bracket identifiers

    Copyright (C) 2026 YANAI Taketo
 *****************************************************************************/

#include "odv_types.h"
#include <stdio.h>

/*---------------------------------------------------------------------------
    SQL export context
 ---------------------------------------------------------------------------*/
typedef struct {
    FILE       *fp;
    int64_t     row_count;
    const char *target_table;
    int         dbms_type;
    int         header_written;
    char        insert_prefix[4096];  /* Cached INSERT INTO ... VALUES ( */
} SQL_CONTEXT;

/*---------------------------------------------------------------------------
    Helper: write SQL-escaped string value
    Escapes single quotes by doubling them.
 ---------------------------------------------------------------------------*/
static void sql_write_string(FILE *fp, const char *val)
{
    fputc('\'', fp);
    while (*val) {
        if (*val == '\'') {
            fputc('\'', fp);
            fputc('\'', fp);
        } else if (*val == '\\' && 0) {
            /* MySQL needs backslash escaping, but we use standard SQL mode */
            fputc('\\', fp);
            fputc('\\', fp);
        } else {
            fputc(*val, fp);
        }
        val++;
    }
    fputc('\'', fp);
}

/*---------------------------------------------------------------------------
    Helper: quote an identifier for the target DBMS
 ---------------------------------------------------------------------------*/
static void sql_write_identifier(FILE *fp, const char *name, int dbms)
{
    switch (dbms) {
    case DBMS_MYSQL:
        fprintf(fp, "`%s`", name);
        break;
    case DBMS_SQLSERVER:
        fprintf(fp, "[%s]", name);
        break;
    case DBMS_ORACLE:
    case DBMS_POSTGRES:
    default:
        fprintf(fp, "\"%s\"", name);
        break;
    }
}

/*---------------------------------------------------------------------------
    Helper: check if a value looks numeric (no quoting needed)
 ---------------------------------------------------------------------------*/
static int is_numeric_value(const char *val)
{
    if (!val || !*val) return 0;
    if (*val == '-' || *val == '+') val++;
    if (!*val) return 0;

    while (*val) {
        if (*val == '.' || (*val >= '0' && *val <= '9')) {
            val++;
        } else {
            return 0;
        }
    }
    return 1;
}

/*---------------------------------------------------------------------------
    build_insert_prefix

    Builds the "INSERT INTO schema.table (col1, col2, ...) VALUES (" prefix
    and caches it for reuse across rows.
 ---------------------------------------------------------------------------*/
static void build_insert_prefix(SQL_CONTEXT *ctx, const char *schema,
                                const char *table, int col_count,
                                const char **col_names, int dbms)
{
    FILE *fp = ctx->fp;
    int i;

    /* We build it directly to file and also mark as built */
    /* Actually, we write the prefix each time for simplicity */
    ctx->header_written = 1;

    /* Write CREATE TABLE comment at the top */
    fprintf(fp, "-- Table: ");
    if (schema && schema[0] != '\0') {
        fprintf(fp, "%s.", schema);
    }
    fprintf(fp, "%s\n", table);
    fprintf(fp, "-- Generated by OraDB DUMP Viewer\n\n");

    /* Build cached prefix string */
    {
        int pos = 0;
        pos += snprintf(ctx->insert_prefix + pos, sizeof(ctx->insert_prefix) - pos,
                        "INSERT INTO ");

        if (schema && schema[0] != '\0') {
            switch (dbms) {
            case DBMS_MYSQL:
                pos += snprintf(ctx->insert_prefix + pos,
                                sizeof(ctx->insert_prefix) - pos, "`%s`.", schema);
                break;
            case DBMS_SQLSERVER:
                pos += snprintf(ctx->insert_prefix + pos,
                                sizeof(ctx->insert_prefix) - pos, "[%s].", schema);
                break;
            default:
                pos += snprintf(ctx->insert_prefix + pos,
                                sizeof(ctx->insert_prefix) - pos, "\"%s\".", schema);
                break;
            }
        }

        switch (dbms) {
        case DBMS_MYSQL:
            pos += snprintf(ctx->insert_prefix + pos,
                            sizeof(ctx->insert_prefix) - pos, "`%s`", table);
            break;
        case DBMS_SQLSERVER:
            pos += snprintf(ctx->insert_prefix + pos,
                            sizeof(ctx->insert_prefix) - pos, "[%s]", table);
            break;
        default:
            pos += snprintf(ctx->insert_prefix + pos,
                            sizeof(ctx->insert_prefix) - pos, "\"%s\"", table);
            break;
        }

        pos += snprintf(ctx->insert_prefix + pos,
                        sizeof(ctx->insert_prefix) - pos, " (");

        for (i = 0; i < col_count; i++) {
            if (i > 0) {
                pos += snprintf(ctx->insert_prefix + pos,
                                sizeof(ctx->insert_prefix) - pos, ", ");
            }
            switch (dbms) {
            case DBMS_MYSQL:
                pos += snprintf(ctx->insert_prefix + pos,
                                sizeof(ctx->insert_prefix) - pos, "`%s`", col_names[i]);
                break;
            case DBMS_SQLSERVER:
                pos += snprintf(ctx->insert_prefix + pos,
                                sizeof(ctx->insert_prefix) - pos, "[%s]", col_names[i]);
                break;
            default:
                pos += snprintf(ctx->insert_prefix + pos,
                                sizeof(ctx->insert_prefix) - pos, "\"%s\"", col_names[i]);
                break;
            }
        }

        pos += snprintf(ctx->insert_prefix + pos,
                        sizeof(ctx->insert_prefix) - pos, ") VALUES (");

        if (pos >= (int)sizeof(ctx->insert_prefix)) {
            ctx->insert_prefix[sizeof(ctx->insert_prefix) - 1] = '\0';
        }
    }
}

/*---------------------------------------------------------------------------
    sql_row_callback
 ---------------------------------------------------------------------------*/
static void __stdcall sql_row_callback(
    const char *schema, const char *table,
    int col_count, const char **col_names, const char **col_values,
    void *user_data)
{
    SQL_CONTEXT *ctx = (SQL_CONTEXT *)user_data;
    int i;

    if (!ctx || !ctx->fp) return;

    /* Filter by table name if specified */
    if (ctx->target_table && ctx->target_table[0] != '\0') {
        if (strcmp(table, ctx->target_table) != 0) return;
    }

    /* Build INSERT prefix on first row */
    if (!ctx->header_written) {
        build_insert_prefix(ctx, schema, table, col_count, col_names, ctx->dbms_type);
    }

    /* Write INSERT statement */
    fputs(ctx->insert_prefix, ctx->fp);

    for (i = 0; i < col_count; i++) {
        if (i > 0) fputs(", ", ctx->fp);

        if (!col_values[i] || col_values[i][0] == '\0') {
            fputs("NULL", ctx->fp);
        } else if (is_numeric_value(col_values[i])) {
            fputs(col_values[i], ctx->fp);
        } else {
            sql_write_string(ctx->fp, col_values[i]);
        }
    }

    fputs(");\n", ctx->fp);
    ctx->row_count++;
}

/*---------------------------------------------------------------------------
    write_sql_file

    Exports a table to SQL INSERT statements.
 ---------------------------------------------------------------------------*/
int write_sql_file(ODV_SESSION *s, const char *table_name,
                   const char *output_path, int dbms_type)
{
    SQL_CONTEXT ctx;
    ODV_ROW_CALLBACK saved_cb;
    void *saved_ud;
    int rc;

    if (!s || !output_path) return ODV_ERROR_INVALID_ARG;

    ctx.fp = fopen(output_path, "wb");
    if (!ctx.fp) {
        odv_strcpy(s->last_error, "Cannot create SQL output file", ODV_MSG_LEN);
        return ODV_ERROR_FOPEN;
    }

    ctx.row_count = 0;
    ctx.target_table = table_name;
    ctx.dbms_type = dbms_type;
    ctx.header_written = 0;
    ctx.insert_prefix[0] = '\0';

    /* Save and replace row callback */
    saved_cb = s->row_cb;
    saved_ud = s->row_ud;
    s->row_cb = sql_row_callback;
    s->row_ud = &ctx;

    /* Re-parse dump */
    s->cancelled = 0;
    s->total_rows = 0;

    switch (s->dump_type) {
    case DUMP_EXPDP:
    case DUMP_EXPDP_COMPRESS:
        rc = parse_expdp_dump(s, 0);
        break;
    case DUMP_EXP:
    case DUMP_EXP_DIRECT:
        rc = parse_exp_dump(s, 0);
        break;
    default:
        rc = ODV_ERROR_FORMAT;
        break;
    }

    fclose(ctx.fp);

    /* Restore original callback */
    s->row_cb = saved_cb;
    s->row_ud = saved_ud;

    return rc;
}
